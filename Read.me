The start for all machine learning system or any system based on Artificial Intelligence is the right DataSet
 necessary for Training and Testing. The DataSet must be similar to the real signals we can observe in real 
 systems going trough different channel conditions. 
Our starting point in our project will be the paper work "Radio Machine Learning Dataset Generation with GNU Radio"
by Tim Oï¿½Shea  and Nathan West in 2016. Since the dataset generated by their contribution is to this day the most
used dataset when it comes to Deep learning solutions for communication systems for training Deep architectures 
for a specific task in this realm.
In their contribution, for building a dataset, it involves the focus on 5 important aspects:
			1 )	Source Alphabet : Two data source; one for analog modulations and other for Digital ones. 
            For analog, a use of continuous signal such as voice, so the use of a publicly available copy of 
            Serial Episode 1. For  Digital source, a use of entire Gutenberg works of Shakespeare in ASCII. 
            To generate the data, the use of a number of modems was necessary using both source for either digital
            or analog.
			2 ) Signal Modulation : this section is more detailed on the paper, and quite bit using particular
             components like " gr-mapper " that was previously introduced by O'Shea in 2014.
			3 ) Channel Simulation : use the GNU Radio Dynamic Channel Model hierarchical block, which includes
             random processes for center frequency offset, sample rate offset, additive white Gaussian noise,
              multi-path, and fading.
			4 ) Normalizing Data : each stored signal is scaled to unit energy in each 128-sample data vector.
			5 ) Packaging Data : store the dataset as an N-dimensional vector using numpy and cPickle. So, this makes
            it obvious that the programming language to use to handle the dataset is python.
We will examine carefully each script used for generating the dataset, to find the repository containing the dataset
for RadioML, see the link bellow :
https://github.com/radioML/dataset

As a result of their contributions to this day we have:
	RadioML 2016.10A : A synthetic dataset, generated with GNU Radio, consisting of 11 modulations 
    (8 digital and 3 analog) at varying signal-to-noise ratios. This represents a cleaner and more normalized
    version of the 2016.04C dataset, which this supersedes
	RadioML 2016.10B : Same as previous RadioML 2016.10A but including AM-SSB. So it's a larger Version.
	RadioML 2016.04C : A synthetic dataset, generated with GNU Radio, consisting of 11 modulations. This is a 
    variable-SNR dataset with moderate LO drift, light fading, and numerous different labeled SNR increments for
    use in measuring performance across different signal and noise power scenarios.
We note that the number " 10 " in the end is referred to the month of release, as stated in october 2016 they've
released the last version of the dataset. The version from april 2016 " 04C ".

For our contribution in this section, we investigate the data generation pipeline and different possibilities 
in order to add different channel conditions like m-Nakagamy fading channel and other aspect. This means we will
see if there is a possibility to have a larger dataset with different conditions just by changing the Channel 
Simulation and preserving the work in sections of source alphabet and signal modulation. Furthermore, we would
like to highlight, that we will visualize the data we are using in order to have a broader vision about the set
we are manipulating and processing. Due to our previous experiences while training deep architectures using 
same datset, we would like to evaluate the value of SNR of the signals stored and compare it to the assigned 
SNR value.

 In order to analyze the entire pipeline used for building the dataset, we proceed with reverse engineering :
This means we begin with the final script " generate_RML2016.10a.py " and follow all the called building scripts
used during. So let's dive on it :

    Script generate_RML2016.10a.py :
    It generates dataset with dynamic channel model across range of SNRs, the output
    format is {('mod type', SNR): np.array(nvecs_per_key, 2, vec_length), etc}. Using cPickle and numpy.
    So, it's mentionned that we want 1000 vector per key, each vector is dimension 128.
    When it comes to SNR, the choosen range is (-20, 20, 2), for python and while visualizing the data we find 
    that we only have SNR  -20db to +18 db with step of 2, the last one 20 was not generated, this is might be
    explained with the fact that range(a, b, s) in python outputs numbers from a to b with step s not including b.
    So this clarification since we have seen a lot of papers mentionning the range of SNR between -20 and 20, but 
    on the figure plots it's clear the SNR stops at 18 db.
    A loop over SNR_values, for each SNR value from that list, we create a loop over transmitters dictionnary
    defined in "transmitters" python file ( included in this folder). This means we will go trough this dictionnary
    transmitters = {"discrete":[transmitter_bpsk, transmitter_qpsk, transmitter_8psk, transmitter_pam4, transmitter_qam16,
     transmitter_qam64, transmitter_gfsk, transmitter_cpfsk],
    "continuous":[transmitter_fm, transmitter_am, transmitter_amssb]}
    We have two keys : "discrete" and "continuous". Next, each element in either "discrete" list or "continous" list was given an index noted i.
    Values of i range from 1 to 8 for digital and for analog from 1 to 3.
    A vector with the desired output dimensions is initialized with zeros.
    So it's easy to follow the next lines that come next, but our focus will be in the line 45 where the SNR value is used.
    Here a variable noise_amp was given SNR value but not in dB, this variable is the parameter of the function "channels.dynamic_channel_model". 
    Channels was imported in the beginning from gnuradio. So let's explore it for a quite bit.
    Also it is important to note that we focus on channels since their we can explore ways for different fadings and other conditions. 
    In the script, the channel function from gnuRadio has different parameters including defined variables above in the script, like: fD, True, 
    delays, mags, ntaps, noise_amp. 
    From gnuRadio for python documentation, refered in the following repository:
    https://github.com/gnuradio/gnuradio
    Particulary, to serve our interest since exploring the entire repository will be time consumming, we jump directly to the channel module:
    https://github.com/gnuradio/gnuradio/tree/master/gr-channels
    For dynamic_channel_model :https://github.com/gnuradio/gnuradio/blob/master/gr-channels/include/gnuradio/channels/dynamic_channel_model.h
    This means in order to follow to the work done so far, we can just modify the following channel parameters in dynamic_channel_model function :
        * \param samp_rate >>>  Input sample rate in Hz
        * \param sro_std_dev >>>  sample rate drift process standard deviation per sample in Hz
        * \param sro_max_dev >>> maximum sample rate offset in Hz
        * \param cfo_std_dev >>>  carrier frequnecy drift process standard deviation per sample in Hz
        * \param cfo_max_dev >>>  maximum carrier frequency offset in Hz
        * \param N >>>  number of sinusoids used in frequency selective fading simulation
        * \param doppler_freq >>>   maximum doppler frequency used in fading simulation in Hz
        * \param LOS_model >>>  defines whether the fading model should include a line of site component. LOS->Rician, NLOS->Rayleigh
        * \param K >>> Rician K-factor, the ratio of specular to diffuse power in the model
        * \param delays >>> A list of fractional sample delays making up the power delay profile
        * \param mags >>>  A list of magnitudes corresponding to each delay time in the power delay profile
        * \param ntaps_mpath >>> The length of the filter to interpolate the power delay profile over. Delays in the PDP must lie between 0 and ntaps_mpath, fractional delays will be sinc-interpolated only to the width of this filter.
        * \param noise_amp >>> Specifies the standard deviation of the AWGN process
        * \param noise_seed >>> A random number generator seed for the noise source.
    In our further release we will build a list for different parameter values to use for specific simulations, in order to cover wide area and
    broad range of channel conditions.
Concerning the different modulations and their generations, they are stated in transmitters.py and it's well defined. This lead us to focusing more
on SNR values after generating the signals. For this, we added another folder intituled "Visualize_data".
Where we can see the different signals and their respective real and imaginary parts and their correspondant values.
Also we added the value of power for each signal and the corresponding SNR. In order to compare the attributed SNR value and the real SNR value of 
synthetic signals in the dataset. 
Concerning mediatools used in source_alphabet.py script can be found in the link bellow:
https://github.com/osh/gr-mediatools
